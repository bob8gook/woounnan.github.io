---
published: false
---





# 선행지식

1. LFH(Low Fragmentation Heap)

   - 힙 단편화(Heap Fragmentation)

     - 잦은 할당과 해제 후, 가용 메모리가 작고 불연속적인 블록들로 나누어진 상태
     
   - 단편화를 해결해주는 메커니즘이 LFH
   
   - windows vista부터 적용
   
   - 제한사항
   
     - 16KB이하의 할당에 대해서만 **동작**
     - HEAP_NO_SERIALIZE로 생성된 힙에는 **미동작**
     - 디버깅 모드에서는 **미동작**
   
   - 구성
   
     >가장 작은 bucket의 사이즈는 8 bytes 이다.
     >
     >
     >
     >​			<Bucket 의 구성>
     >
     >| **Buckets** | **Granularity** | **Range**  |
     >| ----------- | --------------- | ---------- |
     >| 1-32        | 8               | 1-256      |
     >| 33-48       | 16              | 257-512    |
     >| 49-64       | 32              | 513-1024   |
     >| 65-80       | 64              | 1025-2048  |
     >| 81-96       | 128             | 2049-4096  |
     >| 97-112      | 256             | 4097-8192  |
     >| 113-128     | 512             | 8193-16384 |
     >
     >
     >
     >1~32 버킷은 메모리 블록 크키가 8 bytes이며, 1~256 bytes 할당에 사용
     >
     >
     >
     >즉, 1~32 버킷의 graularity가 8 bytes 이므로... 아래와 같은 할당 사이즈를 부여
     >
     >
     >
     >8, 16, 24, 32, 40, 48, 56, 64, 				[1~8]
     >
     >72, 80, 88, 96, 104, 112, 120, 128, 			[9~16]
     >
     >136, 144, 152, 160, 168, 176, 184, 192, 		[17~24]
     >
     >200, 208, 216, 224, 232, 240, 248, 256			[25~32]
     >
     >
     >
     >예를 들어서, 17 bytes 요청이 들어오면 17은 16과 24의 사이이므로 버킷3 (24)의 크기가 사용



<br>

<br>

<br>

# 분석일기

1. 실행 구조

   - 순서도

     <br>

1. 힙 오버플로우?              *2019-08-19-20:15...*
   - `global::load_file()`
     
     - input file에서 `content`를 read하는데 
     
       ```cpp
       pbook = (BOOK*)HeapAlloc(sizeof(BOOK));		
       r = read(fd, pbook, sizeof(BOOK));
       ```
     
     - `pBook->is_unicode`가 set되있을 경우, 2배의 len을 `pBook->content`에 read한다.
     
       ```cpp
       if(pbook->is_unicode) len *= 2;
       
       r = read(fd, pbook->content, len);
       ```
     
     - 그런데, `pBook->content`부터 pBook의 end point까지의 길이는 0x2000미만이므로
     
       힙 오버플로우가 발생할 것이다.
     
       ```cpp
       typedef struct _tagBOOK{
       	char title[32];
       	char abstract[256];
       	void (*fptr)(struct _tagBOOK*);	
       	UINT content_len;
       	BOOL is_unicode;
       	char* content;
       	struct _tagBOOK* next;
       }BOOK;
       ```
     
       *※content는 read되기 전 동적으로 len길이(2배가 되기 전의 len)만큼 할당된다.※*
     
       ```cpp
       pbook->content = (char*)HeapAlloc(pbook->content_len);
       memset(pbook->content, 0, pbook->content_len);
       ```
     
   

---------------------------

3. 아다리가 안맞네...? ------------------------2019-08-20

   - 2개의 책` info`를 입력하려고 하니, 두번째 책 입력받을 때 사이즈가 달라 `content_len`이 제대로 안들어갔다.

   - 원인이 뭔지 확인해봐야 한다...

----

4. 오버플로우는 되는데, fptr을 호출시킬 방법이 없네? ---------------2019-08-21

   -  기존 생각은 2개의 `book`을 generate한 뒤, 1번째 `book`을 free하고 다시 alloc 해서

     앞서 확인한 오버플로우 취약점으로 2번째 book의 fptr값을 덮어써서 익스하려했는데

     생각해보니 내 마음대로 use alloc free 할 수 있는게 아니었네.

   - 방안으로, 사이즈를 다르게 주어 각각 bucket이 생성되도록 해보자

     - (낮은주소) 2nd 버킷   |  (높은주소) 1st 버킷

       2nd 버킷에 값을 할당시켜 1st 버킷을 덮어쓰게 만들자.

     - 그러기 위해선, 사이즈를 다르게 할당해주었을 때 어떤 사이즈가 낮은주소에 할당되는지

       확인해야 한다.
   
       <b>*※요것은 잘못되었다. 사이즈가 다르면 Bucket이 달라져,  overflow를 할 수 없다※*</b>

   - 잠깐만... secure mode를 하면 Bucket 내에서 랜덤으로 할당해줘서, overflow가 가능하다!!
   
     ```cpp
     	UINT R = ((UINT)rand() * 0xdeadbeef) % (n_free_chunk);
     	
     	// secure non-deterministic allocation for heap layout randomization
     		if(this->security_mode == SECURE_HEAP){
     			for(i=0; i<R; i++){
     				// find the index of next available chunk
     				do{
     					idx++;
     				}while(this->getBit(idx));
     			}
    		}
     ```
   
     - 나중에 이걸 확인해보자
     
   -  주의할 점은 `book info`와 `content`가 따로 Alloc 되므로, overflow 시키기 위해선
   
   같은 `heap` 에 할당되어야 하고, 그러기 위해선 `content_len` 사이즈를 `book info` 사이즈(0x140)와 동일하게 설정해야 한다.

-------

5. 주소값 조정에는 성공!!!! 했으나.... ------------------2019-08-22

   - 4번을 바탕으로 secure 랜덤 할당을 이용해 오버플로우 시켜보았다. 그런데...

     - 흐름은 조정했으나.. 내가 계산한 주소값이 호출되지 않았다.

       ![1](/img/lfh-seg.png)

       <b>→ 계산을 다시 해야한다..</b>

     - 위와 다른 내용으로 printf에서 오류가 발생한다

       ![lfh-seg](/img/lfh-segPrint.png)

       <b>→ 할당된 영역과 관련된 내용인것 같은데.. 아직 잘 모르겠다.. 일단 넘기자</b>

----

6. 완벽히 주소값을 다루게 되었다!!!! ---------------------- 2019-08-23

   - 5번에서 계산이 잘못되었던 이유는

     - `overwrite` 의 크기를 잘못 계산했기 때문이었다!

     - `overwrite`는 dummy(`info` 크기만큼) + 함수주소(`fptr`위치)로 계산했었고

     - 단순히 dummy의 크기를 info와 동일하게 생성했으나

     - 실제 dummy의 크기는 + 0x10이 되어야 했었다.

     - `LFH::Alloc`의 chunck_class 계산 코드를 보면

       ```cpp
       void* Alloc(UINT size){
       			UINT chunk_class = (size/0x10) * 0x10 + 0x10;
       			...
       }
       ```

       이렇게 계산되기 때문이다.

   - 어쨌든 성공! (자세한 설명은 나중에 적고)

     ![lfh-ripControl](/img/lfh-ripControl.png)

   - 하지만... 한번의 RIP 컨트롤로 어떻게 익스를 할것인가?

     - one_gadget 주소를 설정하려 했지만, libc 주소는 aslr이 걸려있다..